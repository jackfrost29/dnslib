package nl.sidn.dnslib.logic.unbound;


import org.bridj.Pointer;
import org.bridj.StructObject;
import org.bridj.ann.Field;
import org.bridj.ann.Library;
/**
 * The validation and resolution results.<br>
 * Allocated by the resolver, and need to be freed by the application<br>
 * with ub_resolve_free().<br>
 * <i>native declaration : line 115</i><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> or <a href="http://bridj.googlecode.com/">BridJ</a> .
 */
@Library("unbound") 
public class ub_result extends StructObject {
	/**
	 * The original question, name text string.<br>
	 * C type : char*
	 */
	@Field(0) 
	public Pointer<Byte > qname() {
		return this.io.getPointerField(this, 0);
	}
	/**
	 * The original question, name text string.<br>
	 * C type : char*
	 */
	@Field(0) 
	public ub_result qname(Pointer<Byte > qname) {
		this.io.setPointerField(this, 0, qname);
		return this;
	}
	/** the type asked for */
	@Field(1) 
	public int qtype() {
		return this.io.getIntField(this, 1);
	}
	/** the type asked for */
	@Field(1) 
	public ub_result qtype(int qtype) {
		this.io.setIntField(this, 1, qtype);
		return this;
	}
	/** the class asked for */
	@Field(2) 
	public int qclass() {
		return this.io.getIntField(this, 2);
	}
	/** the class asked for */
	@Field(2) 
	public ub_result qclass(int qclass) {
		this.io.setIntField(this, 2, qclass);
		return this;
	}
	/**
	 * a list of network order DNS rdata items, terminated with a <br>
	 * NULL pointer, so that data[0] is the first result entry,<br>
	 * data[1] the second, and the last entry is NULL. <br>
	 * If there was no data, data[0] is NULL.<br>
	 * C type : char**
	 */
	@Field(3) 
	public Pointer<Pointer<Byte > > data() {
		return this.io.getPointerField(this, 3);
	}
	/**
	 * a list of network order DNS rdata items, terminated with a <br>
	 * NULL pointer, so that data[0] is the first result entry,<br>
	 * data[1] the second, and the last entry is NULL. <br>
	 * If there was no data, data[0] is NULL.<br>
	 * C type : char**
	 */
	@Field(3) 
	public ub_result data(Pointer<Pointer<Byte > > data) {
		this.io.setPointerField(this, 3, data);
		return this;
	}
	/**
	 * the length in bytes of the data items, len[i] for data[i]<br>
	 * C type : int*
	 */
	@Field(4) 
	public Pointer<Integer > len() {
		return this.io.getPointerField(this, 4);
	}
	/**
	 * the length in bytes of the data items, len[i] for data[i]<br>
	 * C type : int*
	 */
	@Field(4) 
	public ub_result len(Pointer<Integer > len) {
		this.io.setPointerField(this, 4, len);
		return this;
	}
	/**
	 * canonical name for the result (the final cname). <br>
	 * zero terminated string.<br>
	 * May be NULL if no canonical name exists.<br>
	 * C type : char*
	 */
	@Field(5) 
	public Pointer<Byte > canonname() {
		return this.io.getPointerField(this, 5);
	}
	/**
	 * canonical name for the result (the final cname). <br>
	 * zero terminated string.<br>
	 * May be NULL if no canonical name exists.<br>
	 * C type : char*
	 */
	@Field(5) 
	public ub_result canonname(Pointer<Byte > canonname) {
		this.io.setPointerField(this, 5, canonname);
		return this;
	}
	/**
	 * DNS RCODE for the result. May contain additional error code if<br>
	 * there was no data due to an error. 0 (NOERROR) if okay.
	 */
	@Field(6) 
	public int rcode() {
		return this.io.getIntField(this, 6);
	}
	/**
	 * DNS RCODE for the result. May contain additional error code if<br>
	 * there was no data due to an error. 0 (NOERROR) if okay.
	 */
	@Field(6) 
	public ub_result rcode(int rcode) {
		this.io.setIntField(this, 6, rcode);
		return this;
	}
	/**
	 * The DNS answer packet. Network formatted. Can contain DNSSEC types.<br>
	 * C type : void*
	 */
	@Field(7) 
	public Pointer<? > answer_packet() {
		return this.io.getPointerField(this, 7);
	}
	/**
	 * The DNS answer packet. Network formatted. Can contain DNSSEC types.<br>
	 * C type : void*
	 */
	@Field(7) 
	public ub_result answer_packet(Pointer<? > answer_packet) {
		this.io.setPointerField(this, 7, answer_packet);
		return this;
	}
	/** length of the answer packet in octets. */
	@Field(8) 
	public int answer_len() {
		return this.io.getIntField(this, 8);
	}
	/** length of the answer packet in octets. */
	@Field(8) 
	public ub_result answer_len(int answer_len) {
		this.io.setIntField(this, 8, answer_len);
		return this;
	}
	/**
	 * If there is any data, this is true.<br>
	 * If false, there was no data (nxdomain may be true, rcode can be set).
	 */
	@Field(9) 
	public int havedata() {
		return this.io.getIntField(this, 9);
	}
	/**
	 * If there is any data, this is true.<br>
	 * If false, there was no data (nxdomain may be true, rcode can be set).
	 */
	@Field(9) 
	public ub_result havedata(int havedata) {
		this.io.setIntField(this, 9, havedata);
		return this;
	}
	/**
	 * If there was no data, and the domain did not exist, this is true.<br>
	 * If it is false, and there was no data, then the domain name <br>
	 * is purported to exist, but the requested data type is not available.
	 */
	@Field(10) 
	public int nxdomain() {
		return this.io.getIntField(this, 10);
	}
	/**
	 * If there was no data, and the domain did not exist, this is true.<br>
	 * If it is false, and there was no data, then the domain name <br>
	 * is purported to exist, but the requested data type is not available.
	 */
	@Field(10) 
	public ub_result nxdomain(int nxdomain) {
		this.io.setIntField(this, 10, nxdomain);
		return this;
	}
	/**
	 * True, if the result is validated securely.<br>
	 * False, if validation failed or domain queried has no security info.<br>
	 * * It is possible to get a result with no data (havedata is false),<br>
	 * and secure is true. This means that the non-existance of the data<br>
	 * was cryptographically proven (with signatures).
	 */
	@Field(11) 
	public int secure() {
		return this.io.getIntField(this, 11);
	}
	/**
	 * True, if the result is validated securely.<br>
	 * False, if validation failed or domain queried has no security info.<br>
	 * * It is possible to get a result with no data (havedata is false),<br>
	 * and secure is true. This means that the non-existance of the data<br>
	 * was cryptographically proven (with signatures).
	 */
	@Field(11) 
	public ub_result secure(int secure) {
		this.io.setIntField(this, 11, secure);
		return this;
	}
	/**
	 * If the result was not secure (secure==0), and this result is due <br>
	 * to a security failure, bogus is true.<br>
	 * This means the data has been actively tampered with, signatures<br>
	 * failed, expected signatures were not present, timestamps on <br>
	 * signatures were out of date and so on.<br>
	 * * If !secure and !bogus, this can happen if the data is not secure <br>
	 * because security is disabled for that domain name. <br>
	 * This means the data is from a domain where data is not signed.
	 */
	@Field(12) 
	public int bogus() {
		return this.io.getIntField(this, 12);
	}
	/**
	 * If the result was not secure (secure==0), and this result is due <br>
	 * to a security failure, bogus is true.<br>
	 * This means the data has been actively tampered with, signatures<br>
	 * failed, expected signatures were not present, timestamps on <br>
	 * signatures were out of date and so on.<br>
	 * * If !secure and !bogus, this can happen if the data is not secure <br>
	 * because security is disabled for that domain name. <br>
	 * This means the data is from a domain where data is not signed.
	 */
	@Field(12) 
	public ub_result bogus(int bogus) {
		this.io.setIntField(this, 12, bogus);
		return this;
	}
	/**
	 * If the result is bogus this contains a string (zero terminated)<br>
	 * that describes the failure.  There may be other errors as well<br>
	 * as the one described, the description may not be perfectly accurate.<br>
	 * Is NULL if the result is not bogus.<br>
	 * C type : char*
	 */
	@Field(13) 
	public Pointer<Byte > why_bogus() {
		return this.io.getPointerField(this, 13);
	}
	/**
	 * If the result is bogus this contains a string (zero terminated)<br>
	 * that describes the failure.  There may be other errors as well<br>
	 * as the one described, the description may not be perfectly accurate.<br>
	 * Is NULL if the result is not bogus.<br>
	 * C type : char*
	 */
	@Field(13) 
	public ub_result why_bogus(Pointer<Byte > why_bogus) {
		this.io.setPointerField(this, 13, why_bogus);
		return this;
	}
	/**
	 * TTL for the result, in seconds.  If the security is bogus, then<br>
	 * you also cannot trust this value.
	 */
	@Field(14) 
	public int ttl() {
		return this.io.getIntField(this, 14);
	}
	/**
	 * TTL for the result, in seconds.  If the security is bogus, then<br>
	 * you also cannot trust this value.
	 */
	@Field(14) 
	public ub_result ttl(int ttl) {
		this.io.setIntField(this, 14, ttl);
		return this;
	}
	public ub_result() {
		super();
	}
	public ub_result(Pointer pointer) {
		super(pointer);
	}
}

